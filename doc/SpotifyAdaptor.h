
/*
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */

#ifndef __dbusxx__SpotifyAdaptor_h__ADAPTOR_MARSHAL_H
#define __dbusxx__SpotifyAdaptor_h__ADAPTOR_MARSHAL_H

#include <dbus-c++-1//dbus-c++/dbus.h>
#include <cassert>

namespace org {
namespace freedesktop {
namespace DBus {

class Peer_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Peer_adaptor()
    : ::DBus::InterfaceAdaptor("org.freedesktop.DBus.Peer")
    {
        register_method(Peer_adaptor, Ping, _Ping_stub);
        register_method(Peer_adaptor, GetMachineId, _GetMachineId_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument Ping_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument GetMachineId_args[] = 
        {
            { "machine_uuid", "s", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod Peer_adaptor_methods[] = 
        {
            { "Ping", Ping_args },
            { "GetMachineId", GetMachineId_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Peer_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Peer_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Peer_adaptor_interface = 
        {
            "org.freedesktop.DBus.Peer",
            Peer_adaptor_methods,
            Peer_adaptor_signals,
            Peer_adaptor_properties
        };
        return &Peer_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual void Ping() = 0;
    virtual std::string GetMachineId() = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _Ping_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        Ping();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _GetMachineId_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argout1 = GetMachineId();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } } 
namespace org {
namespace mpris {

class MediaPlayer2_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    MediaPlayer2_adaptor()
    : ::DBus::InterfaceAdaptor("org.mpris.MediaPlayer2")
    {
        bind_property(CanQuit, "b", true, false);
        bind_property(CanRaise, "b", true, false);
        bind_property(HasTrackList, "b", true, false);
        bind_property(Identity, "s", true, false);
        bind_property(DesktopEntry, "s", true, false);
        bind_property(SupportedUriSchemes, "as", true, false);
        bind_property(SupportedMimeTypes, "as", true, false);
        register_method(MediaPlayer2_adaptor, Raise, _Raise_stub);
        register_method(MediaPlayer2_adaptor, Quit, _Quit_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument Raise_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument Quit_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod MediaPlayer2_adaptor_methods[] = 
        {
            { "Raise", Raise_args },
            { "Quit", Quit_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod MediaPlayer2_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty MediaPlayer2_adaptor_properties[] = 
        {
            { "CanQuit", "b", true, false },
            { "CanRaise", "b", true, false },
            { "HasTrackList", "b", true, false },
            { "Identity", "s", true, false },
            { "DesktopEntry", "s", true, false },
            { "SupportedUriSchemes", "as", true, false },
            { "SupportedMimeTypes", "as", true, false },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface MediaPlayer2_adaptor_interface = 
        {
            "org.mpris.MediaPlayer2",
            MediaPlayer2_adaptor_methods,
            MediaPlayer2_adaptor_signals,
            MediaPlayer2_adaptor_properties
        };
        return &MediaPlayer2_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< bool > CanQuit;
    ::DBus::PropertyAdaptor< bool > CanRaise;
    ::DBus::PropertyAdaptor< bool > HasTrackList;
    ::DBus::PropertyAdaptor< std::string > Identity;
    ::DBus::PropertyAdaptor< std::string > DesktopEntry;
    ::DBus::PropertyAdaptor< std::vector< std::string > > SupportedUriSchemes;
    ::DBus::PropertyAdaptor< std::vector< std::string > > SupportedMimeTypes;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual void Raise() = 0;
    virtual void Quit() = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _Raise_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        Raise();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _Quit_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        Quit();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
};

} } 
namespace org {
namespace mpris {
namespace MediaPlayer2 {

class Player_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Player_adaptor()
    : ::DBus::InterfaceAdaptor("org.mpris.MediaPlayer2.Player")
    {
        bind_property(PlaybackStatus, "s", true, false);
        bind_property(LoopStatus, "s", true, true);
        bind_property(Rate, "d", true, true);
        bind_property(Shuffle, "b", true, true);
        bind_property(Metadata, "a{sv}", true, false);
        bind_property(Volume, "d", true, true);
        bind_property(Position, "x", true, false);
        bind_property(MinimumRate, "d", true, false);
        bind_property(MaximumRate, "d", true, false);
        bind_property(CanGoNext, "b", true, false);
        bind_property(CanGoPrevious, "b", true, false);
        bind_property(CanPlay, "b", true, false);
        bind_property(CanPause, "b", true, false);
        bind_property(CanSeek, "b", true, false);
        bind_property(CanControl, "b", true, false);
        register_method(Player_adaptor, Next, _Next_stub);
        register_method(Player_adaptor, Previous, _Previous_stub);
        register_method(Player_adaptor, Pause, _Pause_stub);
        register_method(Player_adaptor, PlayPause, _PlayPause_stub);
        register_method(Player_adaptor, Stop, _Stop_stub);
        register_method(Player_adaptor, Play, _Play_stub);
        register_method(Player_adaptor, Seek, _Seek_stub);
        register_method(Player_adaptor, SetPosition, _SetPosition_stub);
        register_method(Player_adaptor, OpenUri, _OpenUri_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument Next_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument Previous_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument Pause_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument PlayPause_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument Stop_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument Play_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument Seek_args[] = 
        {
            { "Offset", "x", true },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument SetPosition_args[] = 
        {
            { "TrackId", "o", true },
            { "Position", "x", true },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument OpenUri_args[] = 
        {
            { "Uri", "s", true },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument Seeked_args[] = 
        {
            { "Position", "x", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod Player_adaptor_methods[] = 
        {
            { "Next", Next_args },
            { "Previous", Previous_args },
            { "Pause", Pause_args },
            { "PlayPause", PlayPause_args },
            { "Stop", Stop_args },
            { "Play", Play_args },
            { "Seek", Seek_args },
            { "SetPosition", SetPosition_args },
            { "OpenUri", OpenUri_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Player_adaptor_signals[] = 
        {
            { "Seeked", Seeked_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Player_adaptor_properties[] = 
        {
            { "PlaybackStatus", "s", true, false },
            { "LoopStatus", "s", true, true },
            { "Rate", "d", true, true },
            { "Shuffle", "b", true, true },
            { "Metadata", "a{sv}", true, false },
            { "Volume", "d", true, true },
            { "Position", "x", true, false },
            { "MinimumRate", "d", true, false },
            { "MaximumRate", "d", true, false },
            { "CanGoNext", "b", true, false },
            { "CanGoPrevious", "b", true, false },
            { "CanPlay", "b", true, false },
            { "CanPause", "b", true, false },
            { "CanSeek", "b", true, false },
            { "CanControl", "b", true, false },
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Player_adaptor_interface = 
        {
            "org.mpris.MediaPlayer2.Player",
            Player_adaptor_methods,
            Player_adaptor_signals,
            Player_adaptor_properties
        };
        return &Player_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */
    ::DBus::PropertyAdaptor< std::string > PlaybackStatus;
    ::DBus::PropertyAdaptor< std::string > LoopStatus;
    ::DBus::PropertyAdaptor< double > Rate;
    ::DBus::PropertyAdaptor< bool > Shuffle;
    ::DBus::PropertyAdaptor< std::map< std::string, ::DBus::Variant > > Metadata;
    ::DBus::PropertyAdaptor< double > Volume;
    ::DBus::PropertyAdaptor< int64_t > Position;
    ::DBus::PropertyAdaptor< double > MinimumRate;
    ::DBus::PropertyAdaptor< double > MaximumRate;
    ::DBus::PropertyAdaptor< bool > CanGoNext;
    ::DBus::PropertyAdaptor< bool > CanGoPrevious;
    ::DBus::PropertyAdaptor< bool > CanPlay;
    ::DBus::PropertyAdaptor< bool > CanPause;
    ::DBus::PropertyAdaptor< bool > CanSeek;
    ::DBus::PropertyAdaptor< bool > CanControl;

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual void Next() = 0;
    virtual void Previous() = 0;
    virtual void Pause() = 0;
    virtual void PlayPause() = 0;
    virtual void Stop() = 0;
    virtual void Play() = 0;
    virtual void Seek(const int64_t& Offset) = 0;
    virtual void SetPosition(const ::DBus::Path& TrackId, const int64_t& Position) = 0;
    virtual void OpenUri(const std::string& Uri) = 0;

public:

    /* signal emitters for this interface
     */
    void Seeked(const int64_t& arg1)
    {
        ::DBus::SignalMessage sig("Seeked");
        ::DBus::MessageIter wi = sig.writer();
        wi << arg1;
        emit_signal(sig);
    }

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _Next_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        Next();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _Previous_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        Previous();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _Pause_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        Pause();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _PlayPause_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        PlayPause();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _Stop_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        Stop();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _Play_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        Play();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _Seek_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        int64_t argin1; ri >> argin1;
        Seek(argin1);
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _SetPosition_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        ::DBus::Path argin1; ri >> argin1;
        int64_t argin2; ri >> argin2;
        SetPosition(argin1, argin2);
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _OpenUri_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        OpenUri(argin1);
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
};

} } } 
#endif //__dbusxx__SpotifyAdaptor_h__ADAPTOR_MARSHAL_H
